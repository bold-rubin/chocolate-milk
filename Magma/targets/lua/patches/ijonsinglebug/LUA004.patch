diff --git a/ldebug.c b/ldebug.c
index dcd5b15b..150da181 100644
--- a/ldebug.c
+++ b/ldebug.c
@@ -13,6 +13,7 @@
 #include <stdarg.h>
 #include <stddef.h>
 #include <string.h>
+#include <stdio.h>

 #include "lua.h"

@@ -187,13 +187,16 @@ static const char *upvalname (const Proto *p, int uv) {
 
 static const char *findvararg (CallInfo *ci, int n, StkId *pos) {
   if (clLvalue(s2v(ci->func))->p->is_vararg) {
+    // IJON_SET(1); /* PATCHID: 86727 */
     int nextra = ci->u.l.nextraargs;
 #ifdef MAGMA_ENABLE_FIXES
     if (n >= -nextra) {  /* 'n' is negative */
       *pos = ci->func - nextra - (n + 1);
 #else
     if (n <= nextra) {
+      // IJON_SET(2); /* PATCHID: 81950 */
 #ifdef MAGMA_ENABLE_CANARIES
+      // IJON_MAX(n - 1 + nextra); /* PATCHID: 72297 */
       MAGMA_LOG("LUA001", INT_MAX - nextra <= (n - 1));
 #endif
       *pos = ci->func - nextra + (n - 1);
@@ -845,6 +848,7 @@ static int changedline (const Proto *p, int oldpc, int newpc) {
     return 0;
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+  // IJON_CMP(p->lineinfo, NULL); /* PATCHID: 11338 */
   MAGMA_LOG("LUA002", p->lineinfo == NULL);
 #endif
 #endif
@@ -885,10 +889,12 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {
   const Proto *p = ci_func(ci)->p;
 #endif
   int counthook;
+  // IJON_SET(3); /* PATCHID: 89030 */
   if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  /* no hooks? */
     ci->u.l.trap = 0;  /* don't need to stop again */
     return 0;  /* turn off 'trap' */
   }
+  // IJON_SET(4); /* PATCHID: 35616 */
   pc++;  /* reference is always next instruction */
   ci->u.l.savedpc = pc;  /* save 'pc' */
   counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));
@@ -900,11 +906,13 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {
     ci->callstatus &= ~CIST_HOOKYIELD;  /* erase mark */
     return 1;  /* do not call hook again (VM yielded, so it did not move) */
   }
+  // IJON_SET(5); /* PATCHID: 32523 */
   if (!isIT(*(ci->u.l.savedpc - 1)))  /* top not being used? */
     L->top = ci->top;  /* correct top */
   if (counthook)
     luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  /* call count hook */
   if (mask & LUA_MASKLINE) {
+    // IJON_SET(6); /* PATCHID: 35243 */
 #ifdef MAGMA_ENABLE_FIXES
     /* 'L->oldpc' may be invalid; use zero in this case */
     int oldpc = (L->oldpc < p->sizecode) ? L->oldpc : 0;
@@ -917,6 +925,7 @@ int luaG_traceexec (lua_State *L, const Instruction *pc) {
         changedline(p, oldpc, npci)) {  /* or when enter new line */
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+    IJON_MIN(pcRel(L->oldpc, p)); /* PATCHID: 88200 */
     MAGMA_LOG("LUA004", pcRel(L->oldpc, p) < 0);
 #endif
     if (npci == 0 ||
diff --git a/liolib.c b/liolib.c
index aa3d5149..17dfd82b 100644
--- a/liolib.c
+++ b/liolib.c
@@ -16,6 +16,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <stdio.h>

 #include "lua.h"

@@ -295,6 +295,9 @@ static int io_popen (lua_State *L) {
   luaL_argcheck(L, l_checkmodep(mode), 2, "invalid mode");
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+  // IJON_CMP(mode[0], 'r'); /* PATCHID: 42136 */
+  // IJON_CMP(mode[0], 'w'); /* PATCHID: 59657 */
+  // IJON_CMP(mode[1], '\0'); /* PATCHID: 32130 */
   MAGMA_LOG("LUA003", !l_checkmodep(mode));
 #endif
 #endif
