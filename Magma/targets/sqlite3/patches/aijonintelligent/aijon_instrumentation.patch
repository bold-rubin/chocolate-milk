diff --git a/ext/fts5/fts5_hash.c b/ext/fts5/fts5_hash.c
index 1471dff..f479a8e 100644
--- a/ext/fts5/fts5_hash.c
+++ b/ext/fts5/fts5_hash.c
@@ -462,8 +462,12 @@ static int fts5HashEntrySort(
       ){
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+IJON_DIST((long long)(pIter->nKey+1), (long long)nTerm); /* PATCHID:30910 */
       MAGMA_LOG("%MAGMA_BUG%", MAGMA_AND(pTerm != 0, pIter->nKey+1 < nTerm));
+IJON_CTX((unsigned long long)(pTerm != 0 && pIter->nKey+1 < nTerm)); /* PATCHID:30676 */
 #endif
+IJON_SET((int)(nTerm - (pIter->nKey+1))); /* PATCHID:30024 */
+IJON_MIN((unsigned long long)(pIter->nKey+1)); /* PATCHID:29455 */
       if(pTerm==0 || 0==memcmp(fts5EntryKey(pIter), pTerm, nTerm)) {
 #endif
         Fts5HashEntry *pEntry = pIter;
diff --git a/ext/misc/zipfile.c b/ext/misc/zipfile.c
index 3f4320b..ab47aa3 100644
--- a/ext/misc/zipfile.c
+++ b/ext/misc/zipfile.c
@@ -1579,6 +1579,7 @@ static int zipfileUpdate(
   }
 
   if( nVal>1 ){
+IJON_CMP((unsigned long long)nVal, 2); /* PATCHID:18610 */
     /* Check that "sz" and "rawdata" are both NULL: */
     if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
       zipfileTableErr(pTab, "sz must be NULL");
@@ -1593,6 +1594,7 @@ static int zipfileUpdate(
       if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
         /* data=NULL. A directory */
         bIsDir = 1;
+IJON_SET(bIsDir); /* PATCHID:17671 */
       }else{
         /* Value specified for "data", and possibly "method". This must be
         ** a regular file or a symlink. */
@@ -1629,7 +1631,9 @@ static int zipfileUpdate(
     }
 
     if( rc==SQLITE_OK ){
+IJON_SET((int)rc); /* PATCHID:15630 */
       zPath = (const char*)sqlite3_value_text(apVal[2]);
+IJON_CMP((unsigned long long)zPath, 0); /* PATCHID:15071 */
 #ifdef MAGMA_ENABLE_FIXES
       if( zPath==0 ) zPath = "";
 #else
@@ -1640,6 +1644,7 @@ static int zipfileUpdate(
       nPath = (int)strlen(zPath);
       mTime = zipfileGetTime(apVal[4]);
     }
+IJON_CTX(1); /* PATCHID:17361 */
 
     if( rc==SQLITE_OK && bIsDir ){
       /* For a directory, check that the last character in the path is a
@@ -1655,6 +1660,7 @@ static int zipfileUpdate(
         }else{
 #ifdef MAGMA_ENABLE_FIXES
           nPath = (int)strlen(zPath);
+IJON_INC(nPath); /* PATCHID:16412 */
 #else
           nPath++;
 #ifdef MAGMA_ENABLE_CANARIES
@@ -2022,6 +2028,7 @@ void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
   ** be deflated or simply stored in the zip archive. */
   if( sqlite3_value_type(pData)==SQLITE_NULL ){
     bIsDir = 1;
+IJON_SET(bIsDir); /* PATCHID:14546 */
     iMethod = 0;
   }else{
     aData = sqlite3_value_blob(pData);
@@ -2061,11 +2068,13 @@ void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
     }
   }else{
     if( nName==0 || zName[nName-1]!='/' ){
+IJON_SET(nName); /* PATCHID:14059 */
       zName = zFree = sqlite3_mprintf("%s/", zName);
       if( zName==0 ){
         rc = SQLITE_NOMEM;
         goto zipfile_step_out;
       }
+IJON_CTX(294); /* PATCHID:13532 */
 #ifdef MAGMA_ENABLE_FIXES
       nName = (int)strlen(zName);
 #else
@@ -2074,6 +2083,7 @@ void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
       MAGMA_LOG("%MAGMA_BUG%", (int)strlen(zName) != nName);
 #endif
 #endif
+IJON_CTX(86); /* PATCHID:12532 */
     }else{
       while( nName>1 && zName[nName-2]=='/' ) nName--;
     }
diff --git a/ext/rtree/rtree.c b/ext/rtree/rtree.c
index a2828df..adacaa2 100644
--- a/ext/rtree/rtree.c
+++ b/ext/rtree/rtree.c
@@ -3651,6 +3651,7 @@ static int getNodeSize(
   char *zSql;
   if( isCreate ){
     int iPageSize = 0;
+IJON_SET((int)isCreate); /* PATCHID:8375 */
     zSql = sqlite3_mprintf("PRAGMA %Q.page_size", pRtree->zDb);
     rc = getIntFromStmt(db, zSql, &iPageSize);
     if( rc==SQLITE_OK ){
@@ -3667,6 +3668,8 @@ static int getNodeSize(
         pRtree->zDb, pRtree->zName
     );
     rc = getIntFromStmt(db, zSql, &pRtree->iNodeSize);
+IJON_CMP((unsigned long long)pRtree->iNodeSize, (unsigned long long)448); /* PATCHID:7470 */
+IJON_MIN((unsigned long long)pRtree->iNodeSize); /* PATCHID:7103 */
     if( rc!=SQLITE_OK ){
       *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
 #ifdef MAGMA_ENABLE_FIXES
diff --git a/src/build.c b/src/build.c
index 78e3100..d9c4da1 100644
--- a/src/build.c
+++ b/src/build.c
@@ -2445,6 +2445,8 @@ void sqlite3EndTable(
   ** table itself.  So mark it read-only.
   */
   if( db->init.busy ){
+IJON_CTX(440); /* PATCHID:11799 */
+IJON_CMP((unsigned long long)(pSelect != 0), 1); /* PATCHID:10917 */
 #ifdef MAGMA_ENABLE_FIXES
     if( pSelect ){
       sqlite3ErrorMsg(pParse, "");
diff --git a/src/expr.c b/src/expr.c
index 4f2fd31..52b169b 100644
--- a/src/expr.c
+++ b/src/expr.c
@@ -98,10 +98,14 @@ Expr *sqlite3ExprAddCollateToken(
   int dequote              /* True to dequote pCollName */
 ){
   if( pCollName->n>0 ){
+IJON_MIN((unsigned long long)dequote); /* PATCHID:37788 */
+IJON_CMP((unsigned long long)dequote, (unsigned long long)0); /* PATCHID:37370 */
+IJON_MAX((unsigned long long)pCollName->n); /* PATCHID:37328 */
 #ifdef MAGMA_ENABLE_FIXES
     Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+IJON_SET(dequote); /* PATCHID:37053 */
     MAGMA_LOG("%MAGMA_BUG%", dequote==0);
 #endif
     Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, 1);
@@ -5624,6 +5628,7 @@ static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
   testcase( pExpr->op==TK_AGG_FUNCTION );
   if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;
   switch( pExpr->op ){
+IJON_SET((int)pExpr->op); /* PATCHID:4854 */
     case TK_ISNOT:
     case TK_ISNULL:
     case TK_NOTNULL:
@@ -5680,6 +5685,10 @@ static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
     case TK_GE: {
       Expr *pLeft = pExpr->pLeft;
       Expr *pRight = pExpr->pRight;
+IJON_MIN((unsigned long long)pRight->y.pTab); /* PATCHID:3868 */
+IJON_MIN((unsigned long long)pLeft->y.pTab); /* PATCHID:3020 */
+IJON_CMP((unsigned long long)pRight->op, (unsigned long long)TK_COLUMN); /* PATCHID:2298 */
+IJON_CMP((unsigned long long)pLeft->op, (unsigned long long)TK_COLUMN); /* PATCHID:1283 */
       testcase( pExpr->op==TK_EQ );
       testcase( pExpr->op==TK_NE );
       testcase( pExpr->op==TK_LT );
diff --git a/src/pragma.c b/src/pragma.c
index 5d5a274..5d84566 100644
--- a/src/pragma.c
+++ b/src/pragma.c
@@ -1543,10 +1543,12 @@ void sqlite3Pragma(
   **      PRAGMA schema.integrity_check;
   */
   case PragTyp_INTEGRITY_CHECK: {
+IJON_INC((int)pPragma->ePragTyp); /* PATCHID:33348 */
     int i, j, addr, mxErr;
     Table *pObjTab = 0;     /* Check only this one table, if not NULL */
 
     int isQuick = (sqlite3Tolower(zLeft[0])=='q');
+IJON_SET((int)isQuick); /* PATCHID:32587 */
 
     /* If the PRAGMA command was of the form "PRAGMA <db>.integrity_check",
     ** then iDb is set to the index of the database identified by <db>.
@@ -1672,11 +1674,14 @@ void sqlite3Pragma(
         }
         /* Verify that all NOT NULL columns really are NOT NULL */
         for(j=0; j<pTab->nCol; j++){
+IJON_INC((int)j); /* PATCHID:32039 */
           char *zErr;
           int jmp2;
           if( j==pTab->iPKey ) continue;
           if( pTab->aCol[j].notNull==0 ) continue;
+IJON_SET((int)(pTab->aCol[j].notNull)); /* PATCHID:31805 */
           sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
+IJON_CTX((unsigned long long)204); /* PATCHID:31340 */
 #ifndef MAGMA_ENABLE_FIXES
 #ifdef MAGMA_ENABLE_CANARIES
           MAGMA_LOG("%MAGMA_BUG%", sqlite3VdbeGetOp(v,-1)->opcode!=OP_Column);
diff --git a/src/printf.c b/src/printf.c
index cd6d2c8..bc4e3d1 100644
--- a/src/printf.c
+++ b/src/printf.c
@@ -605,6 +605,7 @@ void sqlite3_str_vappendf(
           e2 = 0;
         }else{
           e2 = exp;
+IJON_MAX((unsigned long long)e2); /* PATCHID:34784 */
         }
         {
           i64 szBufNeeded;           /* Size of a temporary buffer needed */
@@ -612,6 +613,8 @@ void sqlite3_str_vappendf(
           szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
 #else
 #ifdef MAGMA_ENABLE_CANARIES
+IJON_MAX((unsigned long long)width); /* PATCHID:34730 */
+IJON_MAX((unsigned long long)precision); /* PATCHID:34223 */
           MAGMA_LOG("%MAGMA_BUG%", MAX(e2,0) + precision > (((int)-1)&0x7fffffff) - 15 - width);
 #endif
           szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;
diff --git a/src/resolve.c b/src/resolve.c
index 49b609c..2d7c806 100644
--- a/src/resolve.c
+++ b/src/resolve.c
@@ -192,6 +192,9 @@ Bitmask sqlite3ExprColUsed(Expr *pExpr){
 
   n = pExpr->iColumn;
   pExTab = pExpr->y.pTab;
+IJON_MAX((unsigned long long)pExTab->nCol); /* PATCHID:36580 */
+IJON_CMP((unsigned long long)pExTab->nCol, (unsigned long long)BMS); /* PATCHID:35872 */
+IJON_CMP((unsigned long long)(pExTab->tabFlags & TF_HasGenerated), (unsigned long long)TF_HasGenerated); /* PATCHID:35346 */
   assert( pExTab!=0 );
 #ifdef MAGMA_ENABLE_FIXES
   if( (pExTab->tabFlags & TF_HasGenerated)!=0
@@ -200,12 +203,14 @@ Bitmask sqlite3ExprColUsed(Expr *pExpr){
     testcase( pExTab->nCol==BMS-1 );
     testcase( pExTab->nCol==BMS );
     result = pExTab->nCol>=BMS ? ALLBITS : MASKBIT(pExTab->nCol)-1;
+IJON_DIST((long long)result, (long long)(ALLBITS - 1)); /* PATCHID:34900 */
   }else{
 #endif
     testcase( n==BMS-1 );
     testcase( n==BMS );
     if( n>=BMS ) n = BMS-1;
     result = ((Bitmask)1)<<n;
+IJON_SET((int)n); /* PATCHID:34881 */
 #ifdef MAGMA_ENABLE_FIXES
   }
 #else
diff --git a/src/select.c b/src/select.c
index 60ae57e..05472a7 100644
--- a/src/select.c
+++ b/src/select.c
@@ -2960,9 +2960,11 @@ static int multiSelect(
   #endif
   }
 #ifdef MAGMA_ENABLE_FIXES
+IJON_CMP((unsigned long long)pParse->nErr, (unsigned long long)1); /* PATCHID:9049 */
   if( pParse->nErr ) goto multi_select_end;
 #endif
 #ifdef MAGMA_ENABLE_CANARIES
+IJON_MAX((unsigned long long)pParse->nErr); /* PATCHID:8637 */
   MAGMA_LOG("%MAGMA_BUG%", pParse->nErr != 0);
 #endif
   /* Compute collating sequences used by 
@@ -4093,6 +4095,7 @@ static int flattenSubquery(
     }
 #ifdef MAGMA_ENABLE_CANARIES
     MAGMA_LOG("%MAGMA_BUG%", (p->selFlags & SF_Distinct)!=0);
+IJON_CMP((unsigned long long)(p->selFlags & SF_Distinct), (unsigned long long)SF_Distinct); /* PATCHID:6133 */
 #endif
   }
 #ifdef SQLITE_EXTRA_IFNULLROW
@@ -5520,6 +5523,7 @@ static int selectExpander(Walker *pWalker, Select *p){
      pParse->nErr ||
 #endif
      db->mallocFailed || sqliteProcessJoin(pParse, p) ){
+IJON_SET((int)(db->mallocFailed ? 1 : 0)); /* PATCHID:5788 */
       return WRC_Abort;
   }
 #ifdef MAGMA_ENABLE_CANARIES
@@ -6693,10 +6697,12 @@ int sqlite3Select(
    && p->pWin==0
 #endif
 #endif
+
   ){
 #ifdef MAGMA_ENABLE_CANARIES
 #ifndef SQLITE_OMIT_WINDOWFUNC
     MAGMA_LOG("%MAGMA_BUG%", p->pWin != 0);
+IJON_SET((int)(p->pWin != 0)); /* PATCHID:855 */
 #endif
 #endif
     p->selFlags &= ~SF_Distinct;
diff --git a/src/vdbe.c b/src/vdbe.c
index 16ecbc8..a3c883b 100644
--- a/src/vdbe.c
+++ b/src/vdbe.c
@@ -2030,6 +2030,7 @@ case OP_Cast: {                  /* in1 */
 ** register P1.  See the Lt opcode for additional information.
 */
 case OP_Eq:               /* same as TK_EQ, jump, in1, in3 */
+IJON_INC((int)pOp->opcode); /* PATCHID:29380 */
 case OP_Ne:               /* same as TK_NE, jump, in1, in3 */
 case OP_Lt:               /* same as TK_LT, jump, in1, in3 */
 case OP_Le:               /* same as TK_LE, jump, in1, in3 */
@@ -2041,9 +2042,11 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
   u16 flags3;         /* Copy of initial value of pIn3->flags */
 
   pIn1 = &aMem[pOp->p1];
+IJON_SET((int)(flags1 & MEM_Dyn)); /* PATCHID:29181 */
   pIn3 = &aMem[pOp->p3];
   flags1 = pIn1->flags;
   flags3 = pIn3->flags;
+IJON_SET((int)(flags3 & MEM_Dyn)); /* PATCHID:28912 */
   if( (flags1 & flags3 & MEM_Int)!=0 ){
     assert( (pOp->p5 & SQLITE_AFF_MASK)!=SQLITE_AFF_TEXT || CORRUPT_DB );
     /* Common case of comparison of two integers */
@@ -2102,8 +2105,10 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
     /* Neither operand is NULL and we couldn't do the special high-speed
     ** integer comparison case.  So do a general-case comparison. */
     affinity = pOp->p5 & SQLITE_AFF_MASK;
+IJON_SET((int)affinity); /* PATCHID:28784 */
     if( affinity>=SQLITE_AFF_NUMERIC ){
       if( (flags1 | flags3)&MEM_Str ){
+IJON_INC((int)(flags1 | flags3)); /* PATCHID:27825 */
         if( (flags1 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){
           applyNumericAffinity(pIn1,0);
           testcase( flags3==pIn3->flags );
@@ -2155,17 +2160,21 @@ case OP_Ge: {             /* same as TK_GE, jump, in1, in3 */
 
   /* Undo any changes made by applyAffinity() to the input registers. */
 #ifdef MAGMA_ENABLE_FIXES
+IJON_CMP((unsigned long long)(pIn3->flags & MEM_Dyn), (unsigned long long)(flags3 & MEM_Dyn)); /* PATCHID:27249 */
   assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) );
 #endif
 #ifdef MAGMA_ENABLE_CANARIES
   MAGMA_LOG("%MAGMA_BUG%", (pIn3->flags & MEM_Dyn) != (flags3 & MEM_Dyn));
+IJON_INC((int)((pIn3->flags & MEM_Dyn) != (flags3 & MEM_Dyn))); /* PATCHID:27092 */
 #endif
   pIn3->flags = flags3;
 #ifdef MAGMA_ENABLE_FIXES
   assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );
+IJON_CMP((unsigned long long)(pIn1->flags & MEM_Dyn), (unsigned long long)(flags1 & MEM_Dyn)); /* PATCHID:26137 */
 #endif
 #ifdef MAGMA_ENABLE_CANARIES
   MAGMA_LOG("%MAGMA_BUG%", (pIn1->flags & MEM_Dyn) != (flags1 & MEM_Dyn));
+IJON_INC((int)((pIn1->flags & MEM_Dyn) != (flags1 & MEM_Dyn))); /* PATCHID:26074 */
 #endif
   pIn1->flags = flags1;
 
diff --git a/src/vdbemem.c b/src/vdbemem.c
index 969946d..11db3ed 100644
--- a/src/vdbemem.c
+++ b/src/vdbemem.c
@@ -1238,7 +1238,10 @@ static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){
   assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
   assert( !sqlite3VdbeMemIsRowSet(pVal) );
   assert( (pVal->flags & (MEM_Null))==0 );
+IJON_SET((int)pVal->flags); /* PATCHID:21671 */
   if( pVal->flags & (MEM_Blob|MEM_Str) ){
+IJON_CTX(160); /* PATCHID:21083 */
+IJON_CMP((unsigned long long)(pVal->flags & (MEM_Blob|MEM_Str)), (unsigned long long)(MEM_Blob|MEM_Str)); /* PATCHID:20959 */
 #ifdef MAGMA_ENABLE_FIXES
     if( ExpandBlob(pVal) ) return 0;
 #endif
@@ -1247,9 +1250,12 @@ static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){
 #endif
     pVal->flags |= MEM_Str;
     if( pVal->enc != (enc & ~SQLITE_UTF16_ALIGNED) ){
+IJON_CMP((unsigned long long)pVal->enc, (unsigned long long)(enc & ~SQLITE_UTF16_ALIGNED)); /* PATCHID:20367 */
+IJON_SET((int)enc); /* PATCHID:20322 */
       sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);
     }
     if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){
+IJON_CMP((unsigned long long)(enc & SQLITE_UTF16_ALIGNED), (unsigned long long)SQLITE_UTF16_ALIGNED); /* PATCHID:19415 */
       assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );
       if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){
         return 0;
diff --git a/src/where.c b/src/where.c
index 18f3b6d..630dfd8 100644
--- a/src/where.c
+++ b/src/where.c
@@ -2831,6 +2831,7 @@ static int whereLoopAddBtreeIndex(
   ** On the other hand, the extra seeks could end up being significantly
   ** more expensive.  */
   assert( 42==sqlite3LogEst(18) );
+IJON_DIST((long long)saved_nEq, (long long)saved_nSkip); /* PATCHID:10264 */
   if( saved_nEq==saved_nSkip
    && saved_nEq+1<pProbe->nKeyCol
    && saved_nEq==pNew->nLTerm
@@ -2842,6 +2843,7 @@ static int whereLoopAddBtreeIndex(
    && (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==SQLITE_OK
 #endif
   ){
+IJON_CTX((unsigned long long)45); /* PATCHID:9552 */
 #ifdef MAGMA_ENABLE_CANARIES
       MAGMA_LOG("%MAGMA_BUG%", pNew->nLSlot < (pNew->nLTerm+1));
 #endif
@@ -2849,6 +2851,7 @@ static int whereLoopAddBtreeIndex(
     pNew->u.btree.nEq++;
     pNew->nSkip++;
     pNew->aLTerm[pNew->nLTerm++] = 0;
+IJON_CMP((unsigned long long)pNew->nLSlot, (unsigned long long)(pNew->nLTerm+1)); /* PATCHID:9517 */
     pNew->wsFlags |= WHERE_SKIPSCAN;
     nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq+1];
     pNew->nOut -= nIter;
@@ -2861,6 +2864,7 @@ static int whereLoopAddBtreeIndex(
     pNew->nSkip = saved_nSkip;
     pNew->wsFlags = saved_wsFlags;
   }
+IJON_CTX((unsigned long long)420); /* PATCHID:9288 */
 
   WHERETRACE(0x800, ("END %s.addBtreeIdx(%s), nEq=%d, rc=%d\n",
                       pProbe->pTable->zName, pProbe->zName, saved_nEq, rc));
diff --git a/src/whereexpr.c b/src/whereexpr.c
index cb5fb0c..0212f98 100644
--- a/src/whereexpr.c
+++ b/src/whereexpr.c
@@ -1058,6 +1058,12 @@ static void exprAnalyze(
   assert( pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE );
   prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
   op = pExpr->op;
+
+IJON_CMP((unsigned long long) op, (unsigned long long) 224); /* PATCHID:23644 */
+IJON_CMP((unsigned long long) op, (unsigned long long) 179); /* PATCHID:23166 */
+IJON_CMP((unsigned long long) op, (unsigned long long) 141); /* PATCHID:22641 */
+IJON_CMP((unsigned long long) op, (unsigned long long) 167); /* PATCHID:22101 */
+IJON_SET((int) op); /* PATCHID:21856 */
   if( op==TK_IN ){
     assert( pExpr->pRight==0 );
     if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
diff --git a/src/window.c b/src/window.c
index bbd1b88..3263ccd 100644
--- a/src/window.c
+++ b/src/window.c
@@ -895,6 +895,7 @@ static ExprList *exprListAppendList(
   int bIntToNull
 ){
   if( pAppend ){
+IJON_SET((int)(pAppend != 0)); /* PATCHID:25775 */
     int i;
     int nInit = pList ? pList->nExpr : 0;
     for(i=0; i<pAppend->nExpr; i++){
@@ -906,6 +907,7 @@ static ExprList *exprListAppendList(
         break;
       }
       if( bIntToNull ){
+IJON_SET((int)bIntToNull); /* PATCHID:25585 */
         int iDummy;
         Expr *pSub;
         pSub = sqlite3ExprSkipCollateAndLikely(pDup);
